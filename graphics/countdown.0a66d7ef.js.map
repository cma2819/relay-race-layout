{"version":3,"sources":["../../../node_modules/riot/riot.esm.js","../../../node_modules/bianco.dom-to-array/index.next.js","../../../node_modules/bianco.query/index.next.js","../../../node_modules/@riotjs/hot-reload/index.js","components/countdown/countdown.riot","countdown.ts"],"names":["COMPONENTS_IMPLEMENTATION_MAP","Map","DOM_COMPONENT_INSTANCE_PROPERTY","Symbol","PLUGINS_SET","Set","IS_DIRECTIVE","VALUE_ATTRIBUTE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","for","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","Object","freeze","__proto__","checkType","element","type","isFunction","value","noop","autobindMethods","source","methods","forEach","method","bind","callOrAssign","prototype","constructor","dashToCamelCase","string","replace","_","c","toUpperCase","moveChildren","target","firstChild","appendChild","cleanNode","node","clearChildren","childNodes","children","Array","from","removeNode","parentNode","remove","removeChild","EACH","IF","SIMPLE","TAG","SLOT","bindingTypes","ATTRIBUTE","EVENT","TEXT","VALUE","expressionTypes","createTemplateMeta","componentTemplate","fragment","dom","cloneNode","avoidDOMInjection","iOF","indexOf","append","get","parent","start","end","before","isSelect","noSelection","child","insertBefore","selected","selectedIndex","call","querySelectorAll","eqeq","a","b","identity","O","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","length","m","l","isReversed","futureNodes","futureEnd","currentNodes","currentStart","currentEnd","next","list","i","nextSibling","drop","DELETION","INSERTION","SKIP","SKIP_OND","HS","futureStart","futureChanges","currentChanges","k","minLen","link","tresh","nodes","slice","index","idxInOld","findK","newi","oldi","prev","diff","ptr","OND","rows","cols","d","r","pv","cv","pd","v","outer","diffIdx","applyDiff","currentLength","live","currentIndex","push","ktr","j","lo","hi","mid","smartDiff","dropChild","domdiff","options","currentSame","futureSame","checkType$1","isSvg","el","owner","ownerSVGElement","isTemplate","isNil","content","isFunction$1","isBoolean","isObject","UNMOUNT_SCOPE","EachBinding","seal","mount","scope","parentScope","update","placeholder","childrenMap","collection","evaluate","items","createPatch","newChildrenMap","batches","patch","values","fn","unmount","redundant","item","info","pop","template","context","mustFilterItem","condition","Boolean","extendScope","_ref","itemName","indexName","binding","getKey","root","isTemplateTag","create","key","oldItem","clone","mustMount","meta","delete","set","_ref2","document","createTextNode","assign","createDOM","IfBinding","pristine","mustUnmount","create$1","_ref3","memoize","cache","cached","val","has","evaluateAttributeExpressions","attributes","reduce","acc","attribute","name","REMOVE_ATTRIBUTE","SET_ATTIBUTE","ElementProto","Element","isNativeHtmlProperty","hasOwnProperty","setAllAttributes","entries","_ref4","attributeExpression","removeAllAttributes","keys","removeAttribute","_ref5","oldValue","getMethod","normalizeValue","RE_EVENTS_PREFIX","eventExpression","_ref6","normalizedEventName","removeEventListener","addEventListener","normalizeStringValue","getTextNode","childNodeIndex","nodeType","Node","COMMENT_NODE","textNode","replaceChild","textExpression","data","valueExpression","expression","expressions","Expression","apply","create$2","flattenCollectionMethods","map","create$3","_ref7","extendParentScope","attr","SlotBinding","getTemplateScope","templateData","slots","find","_ref8","id","create$6","html","bindings","moveSlotInnerContent","mustRemoveRoot","slot","createSlot","_ref9","getTag","component","slotsToMarkup","slotBindings","_ref10","concat","TagBinding","tag","getComponent","keepRootTag","create$4","_ref11","fixTextExpressionsOffset","textExpressionsOffset","e","create$5","templateTagOffset","selector","redundantAttribute","querySelector","bindingExpressions","createHTMLTree","createElement","innerHTML","createSVGTree","container","svgNode","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createDOMTree","injectDOM","createTemplateDOM","TemplateChunk","Error","Math","max","bindingsData","defineProperty","enumerable","writable","configurable","defineProperties","properties","defineDefaults","defaults","ATTRIBUTE$1","VALUE$1","camelToDashCase","toLowerCase","dashToCamelCase$1","panic","message","evaluateAttributeExpressions$1","domToArray","els","isArray","test","toString","$","ctx","normalize","parseNodes","names","n","attrs","props","prop","setAttribute","CSS_BY_NAME","STYLE_NODE_SELECTOR","getStyleNode","style","head","cssManager","add","css","inject","join","curry","_len","arguments","_key","_len2","args","_key2","getName","tagName","COMPONENT_CORE_HELPERS","$$","PURE_COMPONENT_API","COMPONENT_LIFECYCLE_METHODS","MOCKED_TEMPLATE_INTERFACE","bindDOMNodeToComponentObject","createCoreAPIMethods","mapFunction","componentTemplateFactory","components","createPureComponent","pureFactoryFunction","createComponent","exports","templateFn","createSubcomponents","componentAPI","defineComponent","state","preserveRoot","enhanceComponentAPI","createAttributeBindings","runPlugins","computeState","oldState","newState","addCssHook","newProps","filter","mountComponent","initialProps","componentName","DOMattributesToObject","compose","fns","f","g","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","evaluateInitialProps","register","unregister","keepRootElement","install","plugin","uninstall","implementation","_temp","pure","func","version","__","countdownRep","nodecg","Replicant","Countdown","formatted","raw","progress","onMounted","_this","on","newVal","time","split"],"mappings":";AA0jFA,aAAA,IAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wDAAA,SAAA,EAAA,EAAA,GAAA,GAAA,OAAA,YAAA,OAAA,IAAA,uBAAA,OAAA,UAAA,SAAA,KAAA,GAAA,CAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAAA,IAAA,IAAA,EAAA,EAAA,EAAA,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,QAAA,EAAA,KAAA,EAAA,QAAA,GAAA,EAAA,SAAA,GAAA,GAAA,IAAA,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAAA,OAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,mDAAA,SAAA,EAAA,GAAA,GAAA,OAAA,YAAA,OAAA,IAAA,uBAAA,OAAA,UAAA,SAAA,KAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,CAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,EAAA,QAAA,EAAA,EAAA,OAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,GAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,UAAA,GAAA,QAAA,QAAA,GAAA,QAAA,MAAA,GAAA,QAAA,KAAA,GAAA,QAAA,SAAA,GAAA,QAAA,UAAA,GAAA,QAAA,QAAA,GAAA,QAAA,WAAA,GAAA,QAAA,QAAA,QAAA,QAAA,EAzjFA,IAAMA,EAAgC,IAAIC,IACpCC,EAAkCC,OAAO,kBACzCC,EAAc,IAAIC,IAClBC,EAAe,KACfC,EAAkB,QAClBC,EAAmB,QACnBC,EAAoB,SACpBC,EAAqB,UACrBC,EAAoB,eACpBC,EAAsB,gBACtBC,EAAiB,YACjBC,EAAuB,iBACvBC,EAAiB,YACjBC,EAAwB,kBACxBC,EAAmB,cACnBC,EAAY,QACZC,EAAY,QACZC,EAAY,QACZC,EAAW,OACXC,EAAiBnB,OAAOoB,IAAI,QAC5BC,EAAoBrB,OAAO,UAC3BsB,EAAwBtB,OAAO,cAC/BuB,EAAsBvB,OAAO,YAE/BwB,EAAuBC,OAAOC,OAAO,CACvCC,UAAW,KACX9B,8BAA+BA,EAC/BE,gCAAiCA,EACjCE,YAAaA,EACbE,aAAcA,EACdC,gBAAiBA,EACjBC,iBAAkBA,EAClBC,kBAAmBA,EACnBC,mBAAoBA,EACpBC,kBAAmBA,EACnBC,oBAAqBA,EACrBC,eAAgBA,EAChBC,qBAAsBA,EACtBC,eAAgBA,EAChBC,sBAAuBA,EACvBC,iBAAkBA,EAClBC,UAAWA,EACXC,UAAWA,EACXC,UAAWA,EACXC,SAAUA,EACVC,eAAgBA,EAChBE,kBAAmBA,EACnBC,sBAAuBA,EACvBC,oBAAqBA,IASvB,SAASK,EAAUC,EAASC,GACnB,OAAA,EAAOD,KAAYC,EAQ5B,SAASC,EAAWC,GACXJ,OAAAA,EAAUI,EAAO,YAG1B,SAASC,IACA,OAAA,KAST,SAASC,EAAgBC,EAAQC,GAIxBD,OAHPC,EAAQC,QAAQ,SAAAC,GACdH,EAAOG,GAAUH,EAAOG,GAAQC,KAAKJ,KAEhCA,EAQT,SAASK,EAAaL,GACbJ,OAAAA,EAAWI,GAAUA,EAAOM,WAAaN,EAAOM,UAAUC,YAAc,IAAIP,EAAWA,IAAWA,EAc3G,SAASQ,EAAgBC,GAChBA,OAAAA,EAAOC,QAAQ,SAAU,SAACC,EAAGC,GAAMA,OAAAA,EAAEC,gBAW9C,SAASC,EAAad,EAAQe,GACxBf,EAAOgB,aACTD,EAAOE,YAAYjB,EAAOgB,YAC1BF,EAAad,EAAQe,IAUzB,SAASG,EAAUC,GACjBC,EAAcD,EAAKE,YASrB,SAASD,EAAcE,GACrBC,MAAMC,KAAKF,GAAUpB,QAAQuB,GAS/B,SAASA,EAAWN,GAEhBO,IAAAA,EACEP,EADFO,WAEEP,EAAKQ,OAAQR,EAAKQ,SAEbD,GAAYA,EAAWE,YAAYT,GAG9C,IAAMU,EAAO,EACPC,EAAK,EACLC,EAAS,EACTC,EAAM,EACNC,EAAO,EACTC,EAAe,CACjBL,KAAAA,EACAC,GAAAA,EACAC,OAAAA,EACAC,IAAAA,EACAC,KAAAA,GAEIE,GAAY,EACZC,GAAQ,EACRC,GAAO,EACPC,GAAQ,EACVC,GAAkB,CACpBJ,UAAAA,GACAC,MAAAA,GACAC,KAAAA,GACAC,MAAAA,IAQF,SAASE,GAAmBC,GACpBC,IAAAA,EAAWD,EAAkBE,IAAIC,WAAU,GAC1C,MAAA,CACLC,mBAAmB,EACnBH,SAAAA,EACApB,SAAUC,MAAMC,KAAKkB,EAASrB,aAKvByB,IAAAA,GACP,GADFC,QAGIC,GAAS,SAACC,EAAKC,EAAQ5B,EAAU6B,EAAOC,EAAKC,GAI1CF,IAHDG,IAAAA,GAAW,kBAAmBJ,GAChCK,EAAcD,EAEXH,EAAQC,GAAK,CACZI,IAAAA,EAAQP,EAAI3B,EAAS6B,GAAQ,GAG/BG,GAFJJ,EAAOO,aAAaD,EAAOH,GAEvBC,GAAYC,GAAeC,EAAME,SAAU,CAC7CH,GAAeA,EAEbI,IAAAA,EACET,EADFS,cAEFT,EAAOS,cAAgBA,EAAgB,EAAIR,EAAQL,GAAIc,KAAKV,EAAOW,iBAAiB,UAAWL,GAGjGL,MAIEW,GAAO,SAACC,EAAGC,GAAMD,OAAAA,GAAKC,GAEtBC,GAAW,SAAAC,GAAKA,OAAAA,GAEhBnB,GAAU,SAACoB,EAAWC,EAAWC,EAASC,EAAWC,EAAWC,EAASC,GACvEC,IAAAA,EAASF,EAAUD,EAGrBG,GAAAA,EAAS,EAAG,OAAQ,EAEjBL,KAAAA,EAAUD,GAAaM,GAAQ,CAI7BC,IAHHA,IAAAA,EAAIP,EACJQ,EAAIL,EAEDI,EAAIN,GAAWO,EAAIJ,GAAWC,EAAQN,EAAUQ,GAAIL,EAAUM,KACnED,IACAC,IAGEA,GAAAA,IAAMJ,EAAS,OAAOJ,EAC1BA,EAAYO,EAAI,EAGX,OAAC,GAGJE,GAAa,SAACC,EAAaC,EAAWC,EAAcC,EAAcC,EAAYT,GAC3EQ,KAAAA,EAAeC,GAAcT,EAAQO,EAAaC,GAAeH,EAAYC,EAAY,KAC9FE,IACAF,IAGKA,OAAc,IAAdA,GAGHI,GAAO,SAAClC,EAAKmC,EAAMC,EAAGX,EAAQrB,GAAWgC,OAAAA,EAAIX,EAASzB,EAAImC,EAAKC,GAAI,GAAK,EAAIA,EAAIpC,EAAImC,EAAKC,EAAI,IAAK,GAAGC,YAAcjC,GAEnH1B,GAAS,SAACsB,EAAK3B,EAAU6B,EAAOC,GAC7BD,KAAAA,EAAQC,GAAKmC,GAAKtC,EAAI3B,EAAS6B,MAAW,KAM7CqC,IAAY,EACZC,GAAY,EACZC,GAAO,EACPC,GAAW,GAEXC,GAAK,SAACd,EAAae,EAAad,EAAWe,EAAed,EAAcC,EAAcC,EAAYa,GAClGC,IAAAA,EAAI,EAGJC,EAASH,EAAgBC,EAAiBD,EAAgBC,EACxDG,EAAO3E,MAAM0E,KACbE,EAAQ5E,MAAM0E,GACpBE,EAAM,IAAM,EAEP,IAAA,IAAId,EAAI,EAAGA,EAAIY,EAAQZ,IAAKc,EAAMd,GAAKH,EAIvC,IAFCkB,IAAAA,EAAQpB,EAAaqB,MAAMpB,EAAcC,GAEtCG,EAAIQ,EAAaR,EAAIN,EAAWM,IAAK,CACtCiB,IAAAA,EAAQF,EAAMrD,QAAQ+B,EAAYO,IAEpC,IAAC,EAAIiB,EAAO,CACRC,IAAAA,EAAWD,EAAQrB,GAIpB,GAHLe,EAAIQ,GAAML,EAAOF,EAAQM,MAIvBJ,EAAMH,GAAKO,EACXL,EAAKF,GAAK,CACRS,KAAMpB,EACNqB,KAAMH,EACNI,KAAMT,EAAKF,EAAI,MAShBG,IAHPH,IAAMC,IACJf,EAEKiB,EAAMH,GAAKd,KAAcc,EAEhCC,EAASF,EAAiBD,EAAgBE,EACpCY,IAAAA,EAAOrF,MAAM0E,GACfY,EAAMX,EAAKF,GAGRa,MAFL9B,EAEK8B,GAAK,CAMH9B,IAFH8B,IAAAA,EAAAA,EAFFJ,EAAAA,EAAAA,KACAC,EAAAA,EAAAA,KAGK3B,EAAY0B,GACjBG,IAAOX,GAAUR,KACfV,EAGGG,KAAAA,EAAawB,GAClBE,IAAOX,GAAUT,KACfN,EAGJ0B,IAAOX,GAAUP,KACfX,IACAG,EACF2B,EAAMA,EAAIF,KAGL5B,KAAAA,GAAac,GAClBe,IAAOX,GAAUR,KACfV,EAGGG,KAAAA,GAAcD,GACnB2B,IAAOX,GAAUT,KACfN,EAGG0B,OAAAA,GAKHE,GAAM,SAAChC,EAAae,EAAakB,EAAM/B,EAAcC,EAAc+B,EAAMvC,GACvEC,IAEFuC,EAAGjB,EAAGkB,EAAGtG,EAAGuG,EAAIC,EAAIC,EAFlB3C,EAASqC,EAAOC,EAChBM,EAAI,GAGVC,EAAO,IAAKN,EAAI,EAAGA,GAAKvC,EAAQuC,IAAK,CAE/BA,GAAAA,EAAItB,GAAU,OAAO,KAOpBK,IANLqB,EAAKJ,EAAI,EAGTE,EAAKF,EAAIK,EAAEL,EAAI,GAAK,CAAC,EAAG,GACxBG,EAAKE,EAAEL,GAAK,GAEPjB,GAAKiB,EAAGjB,GAAKiB,EAAGjB,GAAK,EAAG,CASpBpF,IAFPsG,GALEtG,EADEoF,KAAOiB,GAAKjB,IAAMiB,GAAKE,EAAGE,EAAKrB,EAAI,GAAKmB,EAAGE,EAAKrB,EAAI,GAClDmB,EAAGE,EAAKrB,EAAI,GAEZmB,EAAGE,EAAKrB,EAAI,GAAK,GAGfA,EAEDpF,EAAIoG,GAAQE,EAAIH,GAAQtC,EAAQO,EAAaC,EAAerE,GAAIkE,EAAYe,EAAcqB,KAC/FtG,IACAsG,IAGEtG,GAAAA,IAAMoG,GAAQE,IAAMH,EAChBQ,MAAAA,EAGRH,EAAGH,EAAIjB,GAAKpF,GAIVgG,IAAAA,EAAOrF,MAAM0F,EAAI,EAAIvC,EAAS,GAChC8C,EAAUZ,EAAKlC,OAAS,EAEvBuC,IAAAA,EAAIK,EAAE5C,OAAS,EAAGuC,GAAK,EAAGA,IAAK,CAC3BrG,KAAAA,EAAI,GAAKsG,EAAI,GAAKzC,EAAQO,EAAaC,EAAerE,EAAI,GAAIkE,EAAYe,EAAcqB,EAAI,KAEjGN,EAAKY,KAAa9B,GAClB9E,IACAsG,IAGE,IAACD,EAAG,MACRI,EAAKJ,EAAI,EAGTE,EAAKF,EAAIK,EAAEL,EAAI,GAAK,CAAC,EAAG,IACxBjB,EAAIpF,EAAIsG,MAEGD,GAAKjB,IAAMiB,GAAKE,EAAGE,EAAKrB,EAAI,GAAKmB,EAAGE,EAAKrB,EAAI,IAEtDkB,IACAN,EAAKY,KAAa/B,KAGlB7E,IACAgG,EAAKY,KAAahC,IAIfoB,OAAAA,GAGHa,GAAY,SAACb,EAAM3D,EAAKvB,EAAYoD,EAAae,EAAab,EAAcC,EAAcyC,EAAerE,GAMtGgC,IALDsC,IAAAA,EAAO,GACPjD,EAASkC,EAAKlC,OAChBkD,EAAe3C,EACfI,EAAI,EAEDA,EAAIX,GACDkC,OAAAA,EAAKvB,MACNK,KAAAA,GACHG,IACA+B,IACA,MAEGnC,KAAAA,GAEHkC,EAAKE,KAAK/C,EAAYe,IACtB7C,GAAOC,EAAKvB,EAAYoD,EAAae,IAAeA,EAAa+B,EAAeF,EAAgBzE,EAAI+B,EAAa4C,GAAe,GAAKvE,GACrI,MAEGmC,KAAAA,GACHoC,IAOCvC,IAFPA,EAAI,EAEGA,EAAIX,GACDkC,OAAAA,EAAKvB,MACNK,KAAAA,GACHT,IACA,MAEGO,KAAAA,IAEE,EAAImC,EAAK5E,QAAQiC,EAAaC,IAAgBA,IAAoBtD,GAAOsB,EAAK+B,EAAcC,IAAgBA,KAMnHuB,GAAQ,SAACsB,EAAKpD,EAAQqD,GAInBC,IAHHA,IAAAA,EAAK,EACLC,EAAKvD,EAEFsD,EAAKC,GAAI,CACRC,IAAAA,GAAOF,EAAKC,GAAM,IAAM,EAC1BF,EAAID,EAAII,GAAMD,EAAKC,EAASF,EAAKE,EAAM,EAGtCF,OAAAA,GAGHG,GAAY,SAAClF,EAAKvB,EAAYoD,EAAae,EAAad,EAAWe,EAAed,EAAcC,EAAcC,EAAYa,EAAgB2B,EAAejD,EAASpB,GACtKoE,GAAUX,GAAIhC,EAAae,EAAaC,EAAed,EAAcC,EAAcc,EAAgBtB,IAAYmB,GAAGd,EAAae,EAAad,EAAWe,EAAed,EAAcC,EAAcC,EAAYa,GAAiB9C,EAAKvB,EAAYoD,EAAae,EAAab,EAAcC,EAAcyC,EAAerE,IAGjTkC,GAAO,SAAApE,GAAQ,OAACA,EAAKQ,QAAUyG,IAAWxE,KAAKzC,IAErD,SAASiH,KAEL1G,IAAAA,EACE,KADFA,WAIEA,GAAYA,EAAWE,YAAY,MAKzC,IAAMyG,GAAU,SAAC3G,EACjBsD,EACAF,EACAwD,GAKOA,IAASA,EAAU,IAUjBrD,IATDR,IAAAA,EAAU6D,EAAQ7D,SAAWX,GAC7Bb,EAAMqF,EAAQnH,MAAQ8C,GACtBZ,EAA2B,MAAlBiF,EAAQjF,OAAiB,KAAOJ,EAAIqF,EAAQjF,OAAQ,GAC7DqE,EAAgB1C,EAAaN,OAC/BQ,EAAawC,EACbzC,EAAe,EACfF,EAAYD,EAAYJ,OACxBmB,EAAc,EAEXZ,EAAeC,GAAcW,EAAcd,GAAaN,EAAQO,EAAaC,GAAeH,EAAYe,KAC7GZ,IACAY,IAIKZ,KAAAA,EAAeC,GAAcW,EAAcd,GAAaN,EAAQO,EAAaE,EAAa,GAAIJ,EAAYC,EAAY,KAC3HG,IACAH,IAGIwD,IAAAA,EAActD,IAAiBC,EAC/BsD,EAAa3C,IAAgBd,EAE/BwD,GAAAA,GAAeC,EAAY,OAAO1D,EAElCyD,GAAAA,GAAe1C,EAAcd,EAExBD,OADP9B,GAAOC,EAAKvB,EAAYoD,EAAae,EAAad,EAAWI,GAAKlC,EAAK+B,EAAcC,EAAcyC,EAAerE,IAC3GyB,EAIL0D,GAAAA,GAAcvD,EAAeC,EAExBJ,OADPnD,GAAOsB,EAAK+B,EAAcC,EAAcC,GACjCJ,EAGHiB,IAAAA,EAAiBb,EAAaD,EAC9Ba,EAAgBf,EAAYc,EAC9BR,GAAK,EAELU,GAAAA,EAAiBD,GAGf,IAAC,GAFLT,EAAItC,GAAQ+B,EAAae,EAAad,EAAWC,EAAcC,EAAcC,EAAYT,IAKhFK,OAFP9B,GAAOC,EAAKvB,EAAYoD,EAAae,EAAaR,EAAGpC,EAAI+B,EAAaC,GAAe,IACrFjC,GAAOC,EAAKvB,EAAYoD,EAAaO,EAAIU,EAAgBhB,EAAWI,GAAKlC,EAAK+B,EAAcE,EAAYwC,EAAerE,IAChHyB,OAIN,GAAIgB,EAAgBC,IAGhB,GAFLV,EAAItC,GAAQiC,EAAcC,EAAcC,EAAYJ,EAAae,EAAad,EAAWN,IAKhFK,OAFPnD,GAAOsB,EAAK+B,EAAcC,EAAcI,GACxC1D,GAAOsB,EAAK+B,EAAcK,EAAIS,EAAeZ,GACtCJ,EAQTiB,OAAAA,EAAiB,GAAKD,EAAgB,GACxC9C,GAAOC,EAAKvB,EAAYoD,EAAae,EAAad,EAAW9B,EAAI+B,EAAaC,GAAe,IAC7FtD,GAAOsB,EAAK+B,EAAcC,EAAcC,GACjCJ,GAULiB,IAAmBD,GAAiBjB,GAAWC,EAAaC,EAAWC,EAAcC,EAAcC,EAAYT,IACjHzB,GAAOC,EAAKvB,EAAYoD,EAAae,EAAad,EAAWI,GAAKlC,EAAK+B,EAAcE,EAAYwC,EAAerE,IACzGyB,IAITqD,GAAUlF,EAAKvB,EAAYoD,EAAae,EAAad,EAAWe,EAAed,EAAcC,EAAcC,EAAYa,EAAgB2B,EAAejD,EAASpB,GACxJyB,IAUT,SAAS2D,GAAY/I,EAASC,GACrB,OAAA,EAAOD,KAAYC,EAS5B,SAAS+I,GAAMC,GACPC,IAAAA,EAAQD,EAAGE,gBACV,QAAED,GAAmB,OAAVA,EASpB,SAASE,GAAWH,GACX,OAACI,GAAMJ,EAAGK,SASnB,SAASC,GAAapJ,GACb4I,OAAAA,GAAY5I,EAAO,YAS5B,SAASqJ,GAAUrJ,GACV4I,OAAAA,GAAY5I,EAAO,WAS5B,SAASsJ,GAAStJ,GACT,OAACkJ,GAAMlJ,IAAU4I,GAAY5I,EAAO,UAS7C,SAASkJ,GAAMlJ,GACNA,OAAAA,MAAAA,EAGT,IAAMuJ,GAAgBvL,OAAO,WACvBwL,GAAc/J,OAAOgK,KAAK,CAS9BlD,MAAO,GAQPmD,MAAMC,SAAAA,EAAOC,GACJ,OAAA,KAAKC,OAAOF,EAAOC,IAG5BC,OAAOF,SAAAA,EAAOC,GAEVE,IAAAA,EAGE,KAHFA,YACAvD,EAEE,KAFFA,MACAwD,EACE,KADFA,YAEIC,EAAaL,IAAUJ,GAAgB,KAAO,KAAKU,SAASN,GAC5DO,EAAQF,EAAatI,MAAMC,KAAKqI,GAAc,GAC9C3G,EAASyG,EAAYjI,WAMvBsI,EAAAA,GAAYD,EAAOP,EAAOC,EAAa,MAHzCQ,EAAAA,EAAAA,eACAC,EAAAA,EAAAA,QACApF,EAAAA,EAAAA,YAYK,OATPuD,GAAQnF,EAAQkD,EAAOtB,EAAa,CAClCzB,OAAQsG,EACRxI,KAAMgJ,GAAM5I,MAAMC,KAAKoI,EAAYQ,UAAWX,KAGhDS,EAAQhK,QAAQ,SAAAmK,GAAMA,OAAAA,MAEjBT,KAAAA,YAAcK,EACd7D,KAAAA,MAAQtB,EACN,MAGTwF,QAAQd,SAAAA,EAAOC,GAEN,OADFC,KAAAA,OAAON,GAAeK,GACpB,QAWX,SAASU,GAAMI,EAAWd,GACjB,OAAA,SAACe,EAAMC,GACRA,GAAAA,EAAO,EAAG,CACN/K,IAAAA,EAAU6K,EAAUG,MAEtBhL,GAAAA,EAAS,CAETiL,IAAAA,EAEEjL,EAFFiL,SACAC,EACElL,EADFkL,QAIFD,EAASL,QAAQM,EAASnB,EAAa,OAIpCe,OAAAA,GAWX,SAASK,GAAeC,EAAWF,GAC1BE,QAAAA,IAA4C,IAAhCC,QAAQD,EAAUF,IAavC,SAASI,GAAYxB,EAAOyB,GAExBC,IAAAA,EAIED,EAJFC,SACAC,EAGEF,EAHFE,UACA7E,EAEE2E,EAFF3E,MACAkE,EACES,EADFT,KAIKhB,OAFPA,EAAM0B,GAAYV,EACdW,IAAW3B,EAAM2B,GAAa7E,GAC3BkD,EAeT,SAASQ,GAAYD,EAAOP,EAAOC,EAAa2B,GAE5CN,IAAAA,EAQEM,EARFN,UACAH,EAOES,EAPFT,SACAf,EAMEwB,EANFxB,YACAsB,EAKEE,EALFF,SACAG,EAIED,EAJFC,OACAF,EAGEC,EAHFD,UACAG,EAEEF,EAFFE,KACAC,EACEH,EADFG,cAEItB,EAAiB,IAAItM,IACrBuM,EAAU,GACVpF,EAAc,GA4Cb,OA3CPiF,EAAM7J,QAAQ,SAACsK,EAAMlE,GACbsE,IAAAA,EAAUI,GAAY1L,OAAOkM,OAAOhC,GAAQ,CAChD0B,SAAAA,EACAC,UAAAA,EACA7E,MAAAA,EACAkE,KAAAA,IAEIiB,EAAMJ,EAASA,EAAOT,GAAWtE,EACjCoF,EAAU9B,EAAY3G,IAAIwI,GAE5BZ,IAAAA,GAAeC,EAAWF,GAA1BC,CAIEpI,IAAAA,EAAoBiJ,EAAUA,EAAQf,SAAWA,EAASgB,QAC1DhD,EAAK+C,EAAUjJ,EAAkBkG,GAAK2C,EAAK1I,YAC3CgJ,GAAaF,EACbG,EAAON,GAAiBK,EAAYpJ,GAAmBC,GAAqB,GAU9E8I,GARAK,EACF1B,EAAQrC,KAAK,WAAMpF,OAAAA,EAAkB8G,MAAMZ,EAAIiC,EAASnB,EAAaoC,KAErE3B,EAAQrC,KAAK,WAAMpF,OAAAA,EAAkBiH,OAAOkB,EAASnB,KAKnD8B,EAAe,CACXjK,IAAAA,EAAWuK,EAAKvK,UAAYmB,EAAkBnB,SACpDwD,EAAY+C,KAAZ/C,MAAAA,EAAoBxD,EAAAA,SAEpBwD,EAAY+C,KAAKc,GAInBiB,EAAYkC,OAAOL,GAEnBxB,EAAe8B,IAAIN,EAAK,CACtBd,SAAUlI,EACVmI,QAAAA,EACAtE,MAAAA,OAGG,CACL2D,eAAAA,EACAC,QAAAA,EACApF,YAAAA,GAIJ,SAAS0G,GAAOrK,EAAM6K,GAElBlC,IAAAA,EAMEkC,EANFlC,SACAgB,EAKEkB,EALFlB,UACAI,EAIEc,EAJFd,SACAC,EAGEa,EAHFb,UACAE,EAEEW,EAFFX,OACAV,EACEqB,EADFrB,SAEIhB,EAAcsC,SAASC,eAAe,IACtChJ,EAAS/B,EAAKO,WACd4J,EAAOnK,EAAKyB,YAGXtD,OAFP4D,EAAOO,aAAakG,EAAaxI,GACjCM,EAAWN,GACJ7B,OAAO6M,OAAO,GAAI9C,GAAa,CACpCO,YAAa,IAAIjM,IACjBwD,KAAAA,EACAmK,KAAAA,EACAR,UAAAA,EACAhB,SAAAA,EACAyB,cAAezC,GAAWwC,GAC1BX,SAAUA,EAASyB,UAAUjL,GAC7BkK,OAAAA,EACAF,UAAAA,EACAD,SAAAA,EACAvB,YAAAA,IAQJ,IAAM0C,GAAY/M,OAAOgK,KAAK,CAQ5BC,MAAMC,SAAAA,EAAOC,GACJ,OAAA,KAAKC,OAAOF,EAAOC,IAG5BC,OAAOF,SAAAA,EAAOC,GAAa,IAMjB6C,EANiB,EAAA,KACnBzM,IAAU,KAAKiK,SAASN,GACxBoC,GAAa,KAAK/L,OAASA,EAC3B0M,EAAc,KAAK1M,QAAUA,EAS3B,QAAA,GACD+L,KAAAA,EAPCU,EAAW,EAAKnL,KAAKyB,YAC3B,EAAK+G,YAAYjI,WAAW+B,aAAa6I,EAAU,EAAK3C,aACxD,EAAKgB,SAAW,EAAKA,SAASgB,QAC9B,EAAKhB,SAASpB,MAAM+C,EAAU9C,EAAOC,GAMnC,MAEG8C,KAAAA,EACEjC,KAAAA,QAAQd,GACb,MAEF,QACM3J,GAAO,KAAK8K,SAASjB,OAAOF,EAAOC,GAIpC,OADF5J,KAAAA,MAAQA,EACN,MAGTyK,QAAQd,SAAAA,EAAOC,GAEN,OADFkB,KAAAA,SAASL,QAAQd,EAAOC,GAAa,GACnC,QAKX,SAAS+C,GAASrL,EAAMsL,GAEpB3C,IAAAA,EAEE2C,EAFF3C,SACAa,EACE8B,EADF9B,SAEIzH,EAAS/B,EAAKO,WACdiI,EAAcsC,SAASC,eAAe,IAGrC5M,OAFP4D,EAAOO,aAAakG,EAAaxI,GACjCM,EAAWN,GACJ7B,OAAO6M,OAAO,GAAIE,GAAW,CAClClL,KAAAA,EACA2I,SAAAA,EACAH,YAAAA,EACAgB,SAAUA,EAASyB,UAAUjL,KAWjC,SAASuL,GAAQrC,GAAI,IAAA,EAAA,KACbsC,EAAQ,IAAIhP,IAEZiP,EAAS,SAAAC,GACNF,OAAAA,EAAMG,IAAID,GAAOF,EAAM1J,IAAI4J,GAAOF,EAAMZ,IAAIc,EAAKxC,EAAGzG,KAAK,EAAMiJ,KAASF,EAAM1J,IAAI4J,IAIpFD,OADPA,EAAOD,MAAQA,EACRC,EAST,SAASG,GAA6BC,GAC7BA,OAAAA,EAAWC,OAAO,SAACC,EAAKC,GAE3BtN,IAAAA,EAEEsN,EAFFtN,MACAF,EACEwN,EADFxN,KAGM,QAAA,GAED,KAACwN,EAAUC,MAAQzN,IAASwC,GACxB7C,OAAAA,OAAO6M,OAAO,GAAIe,EAAK,GAAIrN,GAG/BF,KAAAA,IAAS2C,GACZ4K,EAAIrN,MAAQsN,EAAUtN,MACtB,MAGF,QACEqN,EAAI1M,EAAgB2M,EAAUC,OAASD,EAAUtN,MAG9CqN,OAAAA,GACN,IAGL,IAAMG,GAAmB,kBACnBC,GAAe,eACfC,GAAkC,oBAAZC,QAA0B,GAAKA,QAAQlN,UAC7DmN,GAAuBf,GAAQ,SAAAU,GAAQG,OAAAA,GAAaG,eAAeN,KASzE,SAASO,GAAiBxM,EAAM6L,GAC9B1N,OAAOsO,QAAQZ,GAAY9M,QAAQ,SAAC2N,GACdA,IAAAA,EAAAA,EAAAA,EADwB,GACvCT,EADuC,EAAA,GACjCvN,EADiC,EAAA,GAErCiO,OAAAA,GAAoB3M,EAAM,CAC/BiM,KAAAA,GACCvN,KAWP,SAASkO,GAAoB5M,EAAM6L,GACjC1N,OAAO0O,KAAKhB,GAAY9M,QAAQ,SAAAiN,GAAahM,OAAAA,EAAK8M,gBAAgBd,KAapE,SAASW,GAAoB3M,EAAM+M,EAAOrO,EAAOsO,GAE7Cf,IAAAA,EACEc,EADFd,KAIGA,IAaAK,GAAqBL,KAAUlE,GAAUrJ,IAAUsJ,GAAStJ,IAAUoJ,GAAapJ,MACtFsB,EAAKiM,GAAQvN,GAGfsB,EAAKiN,GAAUvO,IAAQuN,EAAMiB,GAAejB,EAAMvN,KAf5CA,EACF8N,GAAiBxM,EAAMtB,GACdsO,GAETJ,GAAoB5M,EAAMgN,GAoBhC,SAASC,GAAUvO,GACVkJ,OAAAA,GAAMlJ,KAAoB,IAAVA,GAA6B,KAAVA,GAAgBsJ,GAAStJ,IAAUoJ,GAAapJ,GAASwN,GAAmBC,GAUxH,SAASe,GAAejB,EAAMvN,GAExBA,OAAU,IAAVA,EAAuBuN,EACpBvN,EAGT,IAAMyO,GAAmB,MAWzB,SAASC,GAAgBpN,EAAMqN,EAAO3O,EAAOsO,GAEzCf,IAEIqB,EADFD,EADFpB,KAE+B1M,QAAQ4N,GAAkB,IAEvDH,GACFhN,EAAKuN,oBAAoBD,EAAqBN,GAG5CtO,GACFsB,EAAKwN,iBAAiBF,EAAqB5O,GAAO,GAUtD,SAAS+O,GAAqB/O,GACrBkJ,OAAAA,GAAMlJ,GAAS,GAAKA,EAU7B,IAAMgP,GAAc,SAAC1N,EAAM2N,GACnB/N,IAAAA,EAASI,EAAKE,WAAWyN,GAE3B/N,GAAAA,EAAOgO,WAAaC,KAAKC,aAAc,CACnCC,IAAAA,EAAWjD,SAASC,eAAe,IAElCgD,OADP/N,EAAKgO,aAAaD,EAAUnO,GACrBmO,EAGFnO,OAAAA,GAWT,SAASqO,GAAejO,EAAMkO,EAAMxP,GAClCsB,EAAKkO,KAAOT,GAAqB/O,GAWnC,SAASyP,GAAgBnO,EAAMoO,EAAY1P,GACzCsB,EAAKtB,MAAQ+O,GAAqB/O,GAGpC,IAAI2P,IACDrN,EAAAA,EAAAA,GAAAA,GAAY2L,IACZ1L,EAAAA,EAAAA,GAAQmM,IACRlM,EAAAA,EAAAA,GAAO+M,IACP9M,EAAAA,EAAAA,GAAQgN,IAJX,GAMMG,GAAanQ,OAAOgK,KAAK,CAW7BC,MAAMC,SAAAA,GAKG,OAHF3J,KAAAA,MAAQ,KAAKiK,SAASN,GAE3BkG,GAAM,KAAM,KAAK7P,OACV,MAQT6J,OAAOF,SAAAA,GAEC3J,IAAAA,EAAQ,KAAKiK,SAASN,GAQrB,OANH,KAAK3J,QAAUA,IAEjB6P,GAAM,KAAM7P,GACPA,KAAAA,MAAQA,GAGR,MAOTyK,QAAU,WAGD,OADH,KAAK3K,OAASyC,IAAOsN,GAAM,KAAM,MAC9B,QAWX,SAASA,GAAMH,EAAY1P,GAClB2P,OAAAA,GAAYD,EAAW5P,MAAM4P,EAAWpO,KAAMoO,EAAY1P,EAAO0P,EAAW1P,OAGrF,SAAS8P,GAASxO,EAAMkO,GACf/P,OAAAA,OAAO6M,OAAO,GAAIsD,GAAY,GAAIJ,EAAM,CAC7ClO,KAAMkO,EAAK1P,OAAS0C,GAAOwM,GAAY1N,EAAMkO,EAAKP,gBAAkB3N,IAaxE,SAASyO,GAAyB/F,EAAY5J,EAAS2K,GAC9C3K,OAAAA,EAAQgN,OAAO,SAACC,EAAK/M,GACnBb,OAAAA,OAAO6M,OAAO,GAAIe,EACtB/M,EAAAA,GAAAA,EAAS,SAAAqJ,GACDK,OAAAA,EAAWgG,IAAI,SAAArF,GAAQA,OAAAA,EAAKrK,GAAQqJ,MAAWoB,MAGzD,IAGL,SAASkF,GAAS3O,EAAM4O,GAEpBP,IAAAA,EACEO,EADFP,YAEKlQ,OAAAA,OAAO6M,OAAO,GAAIyD,GAAyBJ,EAAYK,IAAI,SAAAN,GAAcI,OAAAA,GAASxO,EAAMoO,KAAc,CAAC,QAAS,SAAU,aAGnI,SAASS,GAAkBhD,EAAYxD,EAAOC,GACxC,IAACuD,IAAeA,EAAWtI,OAAQ,OAAO+E,EACxC+F,IAAAA,EAAcxC,EAAW6C,IAAI,SAAAI,GAAQ3Q,OAAAA,OAAO6M,OAAO,GAAI8D,EAAM,CACjEpQ,MAAOoQ,EAAKnG,SAASN,OAEhBlK,OAAAA,OAAO6M,OAAO7M,OAAOkM,OAAO/B,GAAe,MAAOsD,GAA6ByC,IAGxF,IAAMU,GAAc5Q,OAAOgK,KAAK,CAI9B0D,WAAY,GAGZmD,iBAAiB3G,SAAAA,EAAOC,GACfuG,OAAAA,GAAkB,KAAKhD,WAAYxD,EAAOC,IAInDF,MAAMC,SAAAA,EAAOC,GAAa,IAAA,EAAA,KAClB2G,IAAe5G,EAAM6G,OAAQ7G,EAAM6G,MAAMC,KAAK,SAACC,GAI5CC,OADHD,EADFC,KAEY,EAAKpD,OAGnB1L,EACE,KAAKP,KADPO,WAUK,OARFiJ,KAAAA,SAAWyF,GAAgBK,GAASL,EAAaM,KAAMN,EAAaO,UAAUvE,UAAU1K,GAEzF,KAAKiJ,WACFA,KAAAA,SAASpB,MAAM,KAAKpI,KAAM,KAAKgP,iBAAiB3G,EAAOC,IACvDkB,KAAAA,SAASrJ,SAAWsP,GAAqB,KAAKzP,OAGrDM,EAAW,KAAKN,MACT,MAGTuI,OAAOF,SAAAA,EAAOC,GAKL,OAJH,KAAKkB,UACFA,KAAAA,SAASjB,OAAO,KAAKyG,iBAAiB3G,EAAOC,IAG7C,MAGTa,QAAQd,SAAAA,EAAOC,EAAaoH,GAKnB,OAJH,KAAKlG,UACFA,KAAAA,SAASL,QAAQ,KAAK6F,iBAAiB3G,EAAOC,GAAc,KAAMoH,GAGlE,QAWX,SAASD,GAAqBE,EAAMxP,QACjB,IAAbA,IACFA,EAAW,IAGPkC,IAAAA,EAAQsN,EAAK9P,WAEfwC,OAAAA,GACFsN,EAAKpP,WAAW+B,aAAaD,EAAOsN,GAC5BtN,CAAAA,GAAUoN,OAAAA,EAAAA,GAAqBE,MAGlCxP,EAUT,SAASyP,GAAW5P,EAAM6P,GAEtB5D,IAAAA,EAEE4D,EAFF5D,KACAJ,EACEgE,EADFhE,WAEK1N,OAAAA,OAAO6M,OAAO,GAAI+D,GAAa,CACpClD,WAAAA,EACA7L,KAAAA,EACAiM,KAAAA,IAaJ,SAAS6D,GAAOC,EAAWb,EAAOrD,GAU5BkE,YATU,IAAVb,IACFA,EAAQ,SAGS,IAAfrD,IACFA,EAAa,IAIXkE,EACKA,EAAU,CACfb,MAAAA,EACArD,WAAAA,IAKGyD,GAASU,GAAcd,GAAYe,GAAAA,OAAAA,EAAAA,GAAaf,IAAQ,CAAA,CAG7Db,YAAaxC,EAAW6C,IAAI,SAAAI,GACnB3Q,OAAAA,OAAO6M,OAAO,CACnBxM,KAAMwC,IACL8N,SAWT,SAASmB,GAAaf,GACbA,OAAAA,EAAMpD,OAAO,SAACC,EAAKmE,GAEtBV,IAAAA,EACEU,EADFV,SAEKzD,OAAAA,EAAIoE,OAAOX,IACjB,IASL,SAASQ,GAAcd,GACdA,OAAAA,EAAMpD,OAAO,SAACC,EAAK4D,GACjB5D,OAAAA,EAAM4D,EAAKJ,MACjB,IAGL,IAAMa,GAAajS,OAAOgK,KAAK,CAS7BC,MAAMC,SAAAA,GACG,OAAA,KAAKE,OAAOF,IAGrBE,OAAOF,SAAAA,EAAOC,GACN2D,IAAAA,EAAO,KAAKtD,SAASN,GAapB,OAXH4D,IAAS,KAAKA,KACXoE,KAAAA,IAAI9H,OAAOF,IAGXc,KAAAA,QAAQd,EAAOC,GAAa,GAE5B2D,KAAAA,KAAOA,EACPoE,KAAAA,IAAMP,GAAO,KAAKQ,aAAarE,GAAO,KAAKiD,MAAO,KAAKrD,YACvDwE,KAAAA,IAAIjI,MAAM,KAAKpI,KAAMqI,IAGrB,MAGTc,QAAQd,SAAAA,EAAOC,EAAaiI,GAMnB,OALH,KAAKF,KAEFA,KAAAA,IAAIlH,QAAQoH,GAGZ,QAKX,SAASC,GAASxQ,EAAMyQ,GAEpB9H,IAAAA,EAIE8H,EAJF9H,SACA2H,EAGEG,EAHFH,aACApB,EAEEuB,EAFFvB,MACArD,EACE4E,EADF5E,WAEK1N,OAAAA,OAAO6M,OAAO,GAAIoF,GAAY,CACnCpQ,KAAAA,EACA2I,SAAAA,EACAuG,MAAAA,EACArD,WAAAA,EACAyE,aAAAA,IAIJ,IAAId,IACD7O,EAAAA,EAAAA,GAAAA,EAAK0K,IACLzK,EAAAA,EAAAA,EAAS+N,IACTjO,EAAAA,EAAAA,EAAO2J,IACPxJ,EAAAA,EAAAA,EAAM2P,IACN1P,EAAAA,EAAAA,EAAO8O,IALV,GAeA,SAASc,GAAyBrC,EAAasC,GACtCtC,OAAAA,EAAYK,IAAI,SAAAkC,GAAKA,OAAAA,EAAEpS,OAAS0C,GAAO/C,OAAO6M,OAAO,GAAI4F,EAAG,CACjEjD,eAAgBiD,EAAEjD,eAAiBgD,IAChCC,IAWP,SAASC,GAAS1G,EAAMF,EAAS6G,GAE7BC,IAAAA,EAIE9G,EAJF8G,SACAvS,EAGEyL,EAHFzL,KACAwS,EAEE/G,EAFF+G,mBACA3C,EACEpE,EADFoE,YAGIrO,EAAO+Q,EAAW5G,EAAK8G,cAAcF,GAAY5G,EAEnD6G,GAAoBhR,EAAK8M,gBAAgBkE,GACvCE,IAAAA,EAAqB7C,GAAe,GAEnC,OAACmB,GAAShR,IAASgR,GAAS5O,IAASZ,EAAM7B,OAAO6M,OAAO,GAAIf,EAAS,CAC3EoE,YAAayC,IAAsBC,EAAWL,GAAyBQ,EAAoBJ,GAAqBI,KAKpH,SAASC,GAAe5B,EAAMpF,GACtBX,IAAAA,EAAW7B,GAAWwC,GAAQA,EAAOW,SAASsG,cAAc,YAE3D5H,OADPA,EAAS6H,UAAY9B,EACd/F,EAAS3B,QAIlB,SAASyJ,GAAc/B,EAAMgC,GAGpBC,OADSD,EAAUE,cAAcC,YAAW,IAAIC,OAAOC,WAAYC,gBAA2DtC,2CAAAA,OAAAA,EAAc,UAAA,mBAAmBuC,iBAAiB,GAWzL,SAASC,GAAc5H,EAAMoF,GACvBhI,OAAAA,GAAM4C,GAAcmH,GAAc/B,EAAMpF,GACrCgH,GAAe5B,EAAMpF,GAU9B,SAAS6H,GAAUxK,EAAIhG,GACb,QAAA,GACD+F,KAAAA,GAAMC,GACT7H,EAAa6B,EAAKgG,GAClB,MAEGG,KAAAA,GAAWH,GACdA,EAAGjH,WAAWyN,aAAaxM,EAAKgG,GAChC,MAEF,QACEA,EAAG1H,YAAY0B,IAWrB,SAASyQ,GAAkBzK,EAAI+H,GACtBA,OAAAA,IAAyB,iBAATA,EAAoBwC,GAAcvK,EAAI+H,GAAQA,GAQvE,IAAM2C,GAAgB/T,OAAOC,OAAO,CAgBlC6M,UAAUzD,SAAAA,GAGD,OADFhG,KAAAA,IAAM,KAAKA,KAAOyQ,GAAkBzK,EAAI,KAAK+H,MAC3C,MAaTnH,MAAMZ,SAAAA,EAAIa,EAAOC,EAAaoC,GAAM,IAAA,EAAA,KAK9B,QAJS,IAATA,IACFA,EAAO,KAGJlD,EAAI,MAAM,IAAI2K,MAAM,2DACrB,KAAK3K,IAAI,KAAK2B,QAAQd,GAOtBqC,IAAAA,EAAAA,EAHFnJ,EAAAA,EAAAA,SACApB,EAAAA,EAAAA,SACAuB,EAAAA,EAAAA,kBAKAnB,GACEJ,EAAWA,EAAS,GAAKqH,GAD3BjH,WAEI6J,EAAgBzC,GAAWH,GAC3BsJ,EAAoB1G,EAAgBgI,KAAKC,IAAIjS,MAAMC,KAAKE,EAAWJ,UAAUyB,QAAQ4F,GAAK,GAAK,KAoB9F,OAnBF4C,KAAAA,cAAgBA,EAEhBa,KAAAA,UAAUzD,GAEX,KAAKhG,MAEFD,KAAAA,SAAWA,GAAY,KAAKC,IAAIC,WAAU,IAK5C+F,KAAAA,GAAK,KAAK4C,cAAgB7J,EAAaiH,EAEvCrH,KAAAA,SAAW,KAAKiK,cAAgBjK,GAAYC,MAAMC,KAAK,KAAKkB,SAASrB,YAAc,MAEnFwB,GAAqB,KAAKH,UAAUyQ,GAAUxK,EAAI,KAAKjG,UAEvDiO,KAAAA,SAAW,KAAK8C,aAAa5D,IAAI,SAAAzE,GAAW4G,OAAAA,GAAS,EAAKrJ,GAAIyC,EAAS6G,KACvEtB,KAAAA,SAASzQ,QAAQ,SAAA8D,GAAKA,OAAAA,EAAEuF,MAAMC,EAAOC,KACnC,MASTC,OAAOF,SAAAA,EAAOC,GAEL,OADFkH,KAAAA,SAASzQ,QAAQ,SAAA8D,GAAKA,OAAAA,EAAE0F,OAAOF,EAAOC,KACpC,MAWTa,QAAQd,SAAAA,EAAOC,EAAaoH,GACtB,GAAA,KAAKlI,GAAI,CAGH,OAFHgI,KAAAA,SAASzQ,QAAQ,SAAA8D,GAAKA,OAAAA,EAAEsG,QAAQd,EAAOC,EAAaoH,MAEjD,GAID,KAAA,KAAKvP,UAA+B,OAAnBuP,EACpBzP,EAAc,KAAKE,UACnB,MAGGuP,KAAmB,IAAnBA,EACHpP,EAAW,KAAKkH,IAChB,MAGGkI,KAAmB,OAAnBA,EACH3P,EAAU,KAAKyH,IAIdA,KAAAA,GAAK,KAGL,OAAA,MAOTgD,MAAQ,WACCrM,OAAAA,OAAO6M,OAAO,GAAI,KAAM,CAC7BxD,GAAI,UAYV,SAAS8H,GAASC,EAAMC,GAKfrR,YAJU,IAAbqR,IACFA,EAAW,IAGNrR,OAAO6M,OAAO,GAAIkH,GAAe,CACtC3C,KAAAA,EACA+C,aAAc9C,IAYlB,SAAS+C,GAAe1T,EAAQyL,EAAK5L,EAAOyI,GAcnCtI,YAbS,IAAZsI,IACFA,EAAU,IAIZhJ,OAAOoU,eAAe1T,EAAQyL,EAAKnM,OAAO6M,OAAO,CAC/CtM,MAAAA,EACA8T,YAAY,EACZC,UAAU,EACVC,cAAc,GACbvL,IAGItI,EAUT,SAAS8T,GAAiB9T,EAAQ+T,EAAYzL,GAKrCtI,OAJPV,OAAOsO,QAAQmG,GAAY7T,QAAQ,SAAC+K,GACfA,IAAAA,EAAAA,EAAAA,EADwB,GACtCQ,EADsC,EAAA,GACjC5L,EADiC,EAAA,GAE3C6T,GAAe1T,EAAQyL,EAAK5L,EAAOyI,KAE9BtI,EAST,SAASgU,GAAehU,EAAQiU,GAKvBjU,OAJPV,OAAOsO,QAAQqG,GAAU/T,QAAQ,SAAC8L,GACbA,IAAAA,EAAAA,EAAAA,EADuB,GACrCP,EADqC,EAAA,GAChC5L,EADgC,EAAA,GAErCG,EAAOyL,KAAMzL,EAAOyL,GAAO5L,KAE3BG,EAGT,IAAMkU,GAAc,EACdC,GAAU,EAOhB,SAASC,GAAgB3T,GAChBA,OAAAA,EAAOC,QAAQ,kBAAmB,SAAS2T,cAQpD,SAASC,GAAkB7T,GAClBA,OAAAA,EAAOC,QAAQ,SAAU,SAACC,EAAGC,GAAMA,OAAAA,EAAEC,gBAS9C,SAAS0T,GAAMC,GACP,MAAA,IAAIlB,MAAMkB,GAQlB,SAASC,GAA+BzH,GAC/BA,OAAAA,EAAWC,OAAO,SAACC,EAAKC,GAE3BtN,IAAAA,EAEEsN,EAFFtN,MACAF,EACEwN,EADFxN,KAGM,QAAA,GAED,KAACwN,EAAUC,MAAQzN,IAASuU,GACxB5U,OAAAA,OAAO6M,OAAO,GAAIe,EAAK,GAAIrN,GAG/BF,KAAAA,IAASwU,GACZjH,EAAIrN,MAAQsN,EAAUtN,MACtB,MAGF,QACEqN,EAAIoH,GAAkBnH,EAAUC,OAASD,EAAUtN,MAGhDqN,OAAAA,GACN,IAQL,SAASwH,GAAWC,GAEd,OAACpT,MAAMqT,QAAQD,GAQZA,EAND,gDAAgDE,KAAKvV,OAAOgB,UAAUwU,SAASlR,KAAK+Q,KAA+B,iBAAfA,EAAIjQ,OAA4BnD,MAAMC,KAAKmT,GAE1I,CAACA,GAcd,SAASI,GAAE7C,EAAU8C,GACZN,OAAAA,GAA+B,iBAAbxC,GAAyB8C,GAAO/I,UAAUpI,iBAAiBqO,GAAYA,GAUlG,IAAM+C,GAAY,SAAA7K,GAAUA,OAAkB,IAAlBA,EAAO1F,OAAe0F,EAAO,GAAKA,GAW9D,SAAS8K,GAAWP,EAAKvH,EAAMjN,GACvBgV,IAAAA,EAAwB,iBAAT/H,EAAoB,CAACA,GAAQA,EAC3C6H,OAAAA,GAAUP,GAAWC,GAAK9E,IAAI,SAAAlH,GAC5BsM,OAAAA,GAAUE,EAAMtF,IAAI,SAAAuF,GAAKzM,OAAAA,EAAGxI,GAAQiV,SA4B/C,SAASrJ,GAAI4I,EAAKvH,EAAMvN,GAChBwV,IAAAA,EAAwB,WAAhB,EAAOjI,GAAoBA,EACtCA,EAAAA,GAAAA,EAAOvN,GAEJyV,EAAQhW,OAAO0O,KAAKqH,GAInBV,OAHPD,GAAWC,GAAKzU,QAAQ,SAAAyI,GACtB2M,EAAMpV,QAAQ,SAAAqV,GAAQ5M,OAAAA,EAAG6M,aAAaD,EAAMF,EAAME,QAE7CZ,EAuBT,SAAS1R,GAAI0R,EAAKvH,GACT8H,OAAAA,GAAWP,EAAKvH,EAAM,gBAG/B,IAAMqI,GAAc,IAAI9X,IAClB+X,GAAsB,cAEtBC,GAAgB,SAAAC,GACb,OAAA,WAIDA,OAAAA,IAIJ7J,GADA6J,EAAQb,GAAEW,IAAqB,IAAMzJ,SAASsG,cAAc,SACjD,OAAQ,YAGdqD,EAAMlU,YAAYuK,SAAS4J,KAAK5U,YAAY2U,GAC1CA,IAbW,GAqBlBE,GAAa,CACfL,YAAAA,GAQAM,IAAI3I,SAAAA,EAAM4I,GAMD,OALFP,GAAY3I,IAAIM,KACnBqI,GAAY1J,IAAIqB,EAAM4I,GACjBC,KAAAA,UAGA,MAQTA,OAAS,WAEA,OADPN,KAAenD,UAAY,EAAIiD,GAAYrL,UAAU8L,KAAK,MACnD,MAQTvU,OAAOyL,SAAAA,GAME,OALHqI,GAAY3I,IAAIM,KAClBqI,GAAY3J,OAAOsB,GACd6I,KAAAA,UAGA,OAYX,SAASE,GAAM9L,GACR,IAAA,IAAI+L,EAAOC,UAAU3R,OAAQwI,EAAM,IAAI3L,MAAM6U,EAAO,EAAIA,EAAO,EAAI,GAAIE,EAAO,EAAGA,EAAOF,EAAME,IACjGpJ,EAAIoJ,EAAO,GAAKD,UAAUC,GAGrB,OAAA,WACA,IAAA,IAAIC,EAAQF,UAAU3R,OAAQ8R,EAAO,IAAIjV,MAAMgV,GAAQE,EAAQ,EAAGA,EAAQF,EAAOE,IACpFD,EAAKC,GAASJ,UAAUI,GAInBD,OADPA,EAAWtJ,GAAAA,OAAAA,EAAQsJ,EAAAA,KACP9R,OAAS2F,EAAG3F,OAASyR,GAAA,WAAM9L,EAAAA,CAAAA,GAAOmM,OAAAA,EAAAA,KAAQnM,EAAA,WAAMmM,EAAAA,EAAAA,KAUhE,SAASE,GAAQhX,GACRuD,OAAAA,GAAIvD,EAAS1B,IAAiB0B,EAAQiX,QAAQtC,cAGvD,IAAMuC,GAAyBtX,OAAOC,OAAO,CAE3CwV,EAAE7C,SAAAA,GACO6C,OAAAA,GAAE7C,EAAU,KAAK5G,MAAM,IAGhCuL,GAAG3E,SAAAA,GACM6C,OAAAA,GAAE7C,EAAU,KAAK5G,SAItBwL,GAAqBxX,OAAOC,QAC/BrB,EAAAA,EAAAA,GAAAA,EAAmB4B,GACnB3B,EAAAA,EAAAA,EAAoB2B,GACpB1B,EAAAA,EAAAA,EAAqB0B,GAHxB,IAKMiX,GAA8BzX,OAAOC,QACxClB,EAAAA,EAAAA,GAAAA,EAAoByB,GACpBxB,EAAAA,EAAAA,EAAsBwB,GACtBvB,EAAAA,EAAAA,EAAiBuB,GACjBtB,EAAAA,EAAAA,EAAuBsB,GACvBrB,EAAAA,EAAAA,EAAiBqB,GACjBpB,EAAAA,EAAAA,EAAwBoB,GACxBnB,EAAAA,EAAAA,EAAmBmB,GAPtB,IASMkX,GAA4B1X,OAAO6M,OAAO,GAAI2K,GAAoB,CACtEnL,MAAO7L,EACPsM,UAAWtM,IASPmX,GAA+B,SAAC9V,EAAM+P,GAAc/P,OAAAA,EAAKvD,GAAmCsT,GAQlG,SAASgG,GAAqBC,GACrB,MAAA,CAACjZ,EAAkBC,EAAmBC,GAAoB6O,OAAO,SAACC,EAAK/M,GAErE+M,OADPA,EAAI/M,GAAUgX,EAAYhX,GACnB+M,GACN,IAUL,SAASkK,GAAyBzM,EAAU0M,GACnC1M,OAAAA,EAAS8F,GAAUlO,GAAiBL,EAAc,SAAAkL,GAChDiK,OAAAA,EAAWjK,IAAS1P,EAA8BuF,IAAImK,KAejE,SAASkK,GAAoBC,EAAqBtM,GAE9CoF,IAAAA,EAKEpF,EALFoF,MACArD,EAIE/B,EAJF+B,WACAsI,EAGErK,EAHFqK,MACAU,EAEE/K,EAFF+K,IAEE/K,EADFN,UAEY4J,GAAM,qCAChByB,GAAKzB,GAAM,mCACTrD,IAAAA,EAAY8C,GAAeuD,EAAoB,CACnDlH,MAAAA,EACArD,WAAAA,EACAsI,MAAAA,IACEwB,IACGI,OAAAA,GAAqB,SAAA/W,GAAU,OAAA,WAC/B,IAAA,IAAIiW,EAAOC,UAAU3R,OAAQ8R,EAAO,IAAIjV,MAAM6U,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IAC/EE,EAAKF,GAAQD,UAAUC,GAKrBnW,GAAAA,IAAWjC,EAAkB,CACxByK,IAAAA,EAAM6N,EADkB,GAE/BS,GAA6BtO,EAAIuI,GAI5BA,OADPA,EAAU/Q,GAAV+Q,MAAAA,EAAqBsF,GACdtF,KAaX,SAASsG,GAAgBxL,GAErBgK,IAAAA,EAIEhK,EAJFgK,IACArL,EAGEqB,EAHFrB,SACA8M,EAEEzL,EAFFyL,QACArK,EACEpB,EADFoB,KAEIsK,EAAa/M,EAAWyM,GAAyBzM,EAAU8M,EAAUE,GAAoBF,EAAQJ,YAAc,IAAML,GACpH,OAAA,SAACvK,GAEJ4D,IAAAA,EAGE5D,EAHF4D,MACArD,EAEEP,EAFFO,WACAsI,EACE7I,EADF6I,MAGEmC,GAAAA,GAAWA,EAAQzY,GAAiB,OAAOsY,GAAoBG,EAAS,CAC1EpH,MAAAA,EACArD,WAAAA,EACAsI,MAAAA,EACAU,IAAAA,EACArL,SAAAA,IAEIiN,IAAAA,EAAevX,EAAaoX,IAAY,GACxCvG,EAAY2G,GAAgB,CAChC7B,IAAAA,EACArL,SAAU+M,EACVE,aAAAA,EACAxK,KAAAA,GAJgByK,CAKf,CACDxH,MAAAA,EACArD,WAAAA,EACAsI,MAAAA,IAMK,MAAA,CACL/L,MAAM7J,SAAAA,EAAS+J,EAAaqO,GACnB5G,OAAAA,EAAU3H,MAAM7J,EAASoY,EAAOrO,IAGzCC,OAAOD,SAAAA,EAAaqO,GACX5G,OAAAA,EAAUxH,OAAOoO,EAAOrO,IAGjCa,QAAQyN,SAAAA,GACC7G,OAAAA,EAAU5G,QAAQyN,MAajC,SAASF,GAAgBhK,GAAO,IAAA,EAE5BmI,EAIEnI,EAJFmI,IACArL,EAGEkD,EAHFlD,SACAiN,EAEE/J,EAFF+J,aACAxK,EACES,EADFT,KAIK+I,OADHH,GAAO5I,GAAM0I,GAAWC,IAAI3I,EAAM4I,GAC/BG,GAAM6B,GAAN7B,CAA2BrC,GAClCE,GAAe4D,EAActY,OAAO6M,OAAO,GAAI4K,GAC5ClY,EAAAA,GAAAA,EAAY,MACVS,OAAO6M,QAETrN,EAAAA,EAAAA,GAAAA,EAAY,MACZC,EAAAA,EAAAA,EAAW,MACX6X,GAAAA,GAAwB,CACzBxJ,KAAAA,EACA4I,IAAAA,EACArL,SAAAA,MAUJ,SAASsN,GAAwB9W,EAAM6L,QAClB,IAAfA,IACFA,EAAa,IAGTwC,IAAAA,EAAcxC,EAAW6C,IAAI,SAAA9L,GAAK4L,OAAAA,GAASxO,EAAM4C,KACjDqH,EAAU,GACT9L,OAAAA,OAAO6M,OAAOf,EAAS9L,OAAO6M,OAAO,CAC1CqD,YAAAA,GACC0H,GAAqB,SAAA/W,GAAU,OAAA,SAAAqJ,GAEzB4B,OADPoE,EAAYtP,QAAQ,SAAA6R,GAAKA,OAAAA,EAAE5R,GAAQqJ,KAC5B4B,OAUX,SAASuM,GAAoBN,GAKpB/X,YAJY,IAAf+X,IACFA,EAAa,IAGR/X,OAAOsO,QAAQvN,EAAagX,IAAapK,OAAO,SAACC,EAAKgB,GACxCA,IAAAA,EAAAA,EAAAA,EADkD,GAChEzC,EADgE,EAAA,GAC3D5L,EAD2D,EAAA,GAG9DqN,OADPA,EAAIkH,GAAgB3I,IAAQ+L,GAAgB3X,GACrCqN,GACN,IASL,SAASgL,GAAWhH,GACX,OAAA,EAAIpT,GAAamP,OAAO,SAACrM,EAAGyJ,GAAOA,OAAAA,EAAGzJ,IAAMA,GAAGsQ,GAUxD,SAASiH,GAAaC,EAAUC,GACvB/Y,OAAAA,OAAO6M,OAAO,GAAIiM,EAAU,GAAI/X,EAAagY,IAUtD,SAASC,GAAW5Y,EAAS0N,GACvBsJ,GAAQhX,KAAa0N,GACvBrB,GAAIrM,EAAS1B,EAAcoP,GAY/B,SAAS4K,GAAoB9G,EAAW1C,GAEpC6B,IAAAA,EAGE7B,EAHF6B,MACArD,EAEEwB,EAFFxB,WACAsI,EACE9G,EADF8G,MAEKvV,OAAAA,EAAgBmY,GAAWpE,GAAiBxU,OAAOkM,OAAO0F,GAAY,CAC3E3H,MAAM7J,SAAAA,EAASoY,EAAOrO,GAuBb,YAtBO,IAAVqO,IACFA,EAAQ,IAGL3Y,KAAAA,GAAyB8Y,GAAwBvY,EAASsN,GAAYzD,MAAME,GACjFiK,GAAe,KAAM9U,EAAWU,OAAOC,OAAOD,OAAO6M,OAAO,GAAImJ,EAAO,GAAIb,GAA+B,KAAKtV,GAAuBqQ,gBACjI3Q,KAAAA,GAAasZ,GAAa,KAAKtZ,GAAYiZ,GAC3C1Y,KAAAA,GAAuB,KAAKuL,SAASyB,UAAU1M,GAASiM,QAE7DsL,GAA6BvX,EAAS,MAEtCwR,EAAU9D,MAAQkL,GAAW5Y,EAASwR,EAAU9D,MAEhDsG,GAAe,KAAM3U,EAAUW,GAE/BgU,GAAe,KAAM5U,EAAWuR,GAE3B/R,KAAAA,GAAqB,KAAKM,GAAY,KAAKC,IAE3CO,KAAAA,GAAqBmK,MAAM7J,EAAS,KAAM+J,GAC1CvK,KAAAA,GAAqBuK,EACrBlL,KAAAA,GAAgB,KAAKK,GAAY,KAAKC,IACpC,MAGT6K,OAAOoO,SAAAA,EAAOrO,QACE,IAAVqO,IACFA,EAAQ,IAGNrO,GACGtK,KAAAA,GAAuBuK,OAAOD,GAG/B8O,IAAAA,EAAW9D,GAA+B,KAAKtV,GAAuBqQ,aACxE,IAAuD,IAAvD,KAAKnR,GAAmBka,EAAU,KAAK3Z,IAMpC,OALP8U,GAAe,KAAM9U,EAAWU,OAAOC,OAAOD,OAAO6M,OAAO,GAAImJ,EAAO,GAAIiD,KACtE1Z,KAAAA,GAAasZ,GAAa,KAAKtZ,GAAYiZ,GAC3CtZ,KAAAA,GAAsB,KAAKI,GAAY,KAAKC,IAC5CO,KAAAA,GAAqBsK,OAAO,KAAM,KAAKxK,IACvCT,KAAAA,GAAgB,KAAKG,GAAY,KAAKC,IACpC,MAGTyL,QAAQyN,SAAAA,GAOC,OANFrZ,KAAAA,GAAuB,KAAKE,GAAY,KAAKC,IAC7CM,KAAAA,GAAuBmL,UAGvBlL,KAAAA,GAAqBkL,QAAQ,KAAM,KAAKpL,GAAqC,OAAjB6Y,EAAwB,MAAQA,GAC5FpZ,KAAAA,GAAkB,KAAKC,GAAY,KAAKC,IACtC,SAGNS,OAAO0O,KAAKkD,GAAWsH,OAAO,SAAAjD,GAAQ3V,OAAAA,EAAWsR,EAAUqE,OAUlE,SAASkD,GAAe/Y,EAASgZ,EAAcC,GACvCvL,IAAAA,EAAOuL,GAAiBjC,GAAQhX,GAK/BwR,OAJFxT,EAA8BoP,IAAIM,IAAOmH,GAA8BnH,wBAAAA,OAAAA,EAA9B,2BAC5B1P,EAA8BuF,IAAImK,EAAlC1P,CAAwC,CACxD4X,MAAOoD,IAEQnP,MAAM7J,GASzB,SAASkZ,GAAsBlZ,GACtB6B,OAAAA,MAAMC,KAAK9B,EAAQsN,YAAYC,OAAO,SAACC,EAAKC,GAE1CD,OADPA,EAAIoH,GAAkBnH,EAAUC,OAASD,EAAUtN,MAC5CqN,GACN,IAkBL,SAAS2L,KACF,IAAA,IAAItC,EAAQF,UAAU3R,OAAQoU,EAAM,IAAIvX,MAAMgV,GAAQE,EAAQ,EAAGA,EAAQF,EAAOE,IACnFqC,EAAIrC,GAASJ,UAAUI,GAGlBqC,OAAAA,EAAI7L,OAAO,SAAC8L,EAAGC,GAAM,OAAA,WACnBD,OAAAA,EAAEC,EAAA,WAAK3C,EAAAA,eAKiB4C,IAAAA,GAG/B5Z,EAHFzB,gCAC+Bsb,GAE7B7Z,EAFF3B,8BACayb,GACX9Z,EADFvB,YASF,SAASsb,GAAqB1Z,EAASgZ,GAK9BpZ,YAJc,IAAjBoZ,IACFA,EAAe,IAGVpZ,OAAO6M,OAAO,GAAIyM,GAAsBlZ,GAAU,GAAIW,EAAaqY,IAc5E,SAASW,GAASjM,EAAMnC,GAEpB+K,IAAAA,EAGE/K,EAHF+K,IACArL,EAEEM,EAFFN,SACA8M,EACExM,EADFwM,QASKyB,OAPHA,GAAgCpM,IAAIM,IAAOmH,GAAwBnH,kBAAAA,OAAAA,EAAxB,6BAC/C8L,GAAgCnN,IAAIqB,EAAMoK,GAAgB,CACxDpK,KAAAA,EACA4I,IAAAA,EACArL,SAAAA,EACA8M,QAAAA,KAEKyB,GAQT,SAASI,GAAWlM,GAIX8L,OAHFA,GAAgCpM,IAAIM,IAAOmH,GAAwBnH,kBAAAA,OAAAA,EAAxB,2BAChD8L,GAAgCpN,OAAOsB,GACvC0I,GAAWnU,OAAOyL,GACX8L,GAUT,SAAS3P,GAAM2I,EAAUwG,EAActL,GAC9B2H,OAAAA,GAAE7C,GAAUrC,IAAI,SAAAnQ,GAAW+Y,OAAAA,GAAe/Y,EAAS0Z,GAAqB1Z,EAASgZ,GAAetL,KASzG,SAAS9C,GAAQ4H,EAAUqH,GAClBxE,OAAAA,GAAE7C,GAAUrC,IAAI,SAAAnQ,GAKdA,OAJHA,EAAQuZ,KACVvZ,EAAQuZ,IAAmC3O,QAAQiP,GAG9C7Z,IASX,SAAS8Z,GAAQC,GAIRN,OAHFvZ,EAAW6Z,IAASlF,GAAM,oCAC3B4E,GAAcrM,IAAI2M,IAASlF,GAAM,mCACrC4E,GAAcpD,IAAI0D,GACXN,GAQT,SAASO,GAAUD,GAGVN,OAFFA,GAAcrM,IAAI2M,IAASlF,GAAM,mCACtC4E,GAAcrN,OAAO2N,GACdN,GAQT,SAASjI,GAAUyI,GACV,OAAA,SAAUhR,EAAI2M,EAAOsE,GAItBA,IAAAA,OAAU,IAAVA,EAAmB,GAAKA,EAF1BvJ,EAAAA,EAAAA,MACArD,EAAAA,EAAAA,WAEK6L,OAAAA,GAAQ,SAAAjY,GAAKA,OAAAA,EAAE2I,MAAMZ,IAAK,SAAA/H,GAAKA,OAAAA,EAAE,CACtC0U,MAAO8D,GAAqBzQ,EAAI2M,GAChCjF,MAAAA,EACArD,WAAAA,KACEwK,GAJGqB,CAIcc,IASzB,SAASE,GAAKC,GAGLA,OAFFla,EAAWka,IAAOvF,GAAM,uDAC7BuF,EAAK9a,IAAkB,EAChB8a,EAIT,IAAMC,GAAU,SAEhB,QAAA,QAAA,GAAA,IAAMC,GAAK,CACTlE,WAAAA,GACA0B,gBAAAA,GACAK,gBAAAA,GACAxY,QAAAA,GAJF,QAAA,GAAA;;ACpiFC,aAjBc,SAASqV,EAAWC,GAE7B,OAACpT,MAAMqT,QAAQD,GAcZA,EAXH,gDACGE,KAAKvV,OAAOgB,UAAUwU,SAASlR,KAAK+Q,KACZ,iBAAfA,EAAIjQ,OAETnD,MAAMC,KAAKmT,GAIX,CAACA,GAIb,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA;;ACTA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA,EAbD,IAAA,EAAA,EAAA,QAAA,wBAaC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GALc,SAASI,EAAE7C,EAAU8C,GAC3B,OAAA,EAAW,EAAA,SAAoB,iBAAb9C,GACtB8C,GAAO/I,UAAUpI,iBAAiBqO,GACnCA;;;;AC8BJ,IAAA,EAAA,EAAA,UAAA,IAzCA,SAAA,EAAA,GACA,iBAAA,SAAA,oBAAA,OAAA,EAAA,QAAA,QAAA,QAAA,QAAA,iBACA,mBAAA,GAAA,EAAA,IAAA,EAAA,CAAA,UAAA,OAAA,gBAAA,GACA,GAAA,EAAA,GAAA,MAAA,cAAA,GAAA,EAAA,KAAA,EAAA,GAHA,CAIA,KAAA,SAAA,EAAA,EAAA,GAAA,aAEA,EAAA,GAAA,EAAA,eAAA,WAAA,EAAA,QAAA,EAEA,MAAA,WAAA,GAAA,EAAA,IACA,gCAAA,GAAA,EAAA,GAAA,QAEA,SAAA,EAAA,GACA,MAAA,KAAA,GAAA,EAEA,OAAA,EAKA,KAAA,UAAA,MAAA,IAAA,IACA,MAAA,EAAA,EAAA,GAGA,EAAA,SAAA,GAEA,EAAA,OAAA,GAGA,MAAA,EAAA,EAAA,UAAA,EAAA,CAAA,EAAA,EAAA,OAGA,OAFA,EAAA,OAAA,EAAA,OAEA,KAhBA,QAAA,KAAA,4CACA,IAmBA,EAAA,QAAA,EACA,EAAA,OAAA,EAEA,OAAA,eAAA,EAAA,aAAA,CAAA,OAAA;;AClBe,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAnBf,IAAI+H,EAAeC,OAAOC,UAAU,aACpC,SAASC,IACE,MAAA,CACHtC,MAAO,CACHuC,UAAW,GACXC,IAAK,EACLC,SAAU,GAEdC,UAAW,WACHC,IAAAA,EAAQ,KACZR,EAAaS,GAAG,SAAU,SAAUC,GAChCF,EAAM3C,MAAMuC,UAAYM,EAAOC,KAAKP,UACpCI,EAAM3C,MAAMyC,UAA+C,GAAnCI,EAAOC,KAAKN,IAAO,MAC3CG,EAAM/Q,aAMP,IAAA,EAAA,CAAA,IAAA,kFAEF0Q,QAAAA,EAEC,SAAA,SAASzP,EAAUpI,EAAiBL,EAAcuP,GACrD9G,OAAAA,EACL,+HACA,CAAC,CACuB,mBAAA,SACV,SAAA,WAEG,YAAA,CAAC,CACNpI,KAAAA,EAAgBF,KACN,eAAA,EAEN,SAAA,SAASmH,GACZ,MAAA,CAAC,eAAgBA,EAAMsO,MAAMuC,UAAUQ,MAAM,KAAK,GAAI,YAAY3E,KAAK,QAGjF,CACqB,mBAAA,SACV,SAAA,WAEG,YAAA,CAAC,CACN3T,KAAAA,EAAgBJ,UAChB,KAAA,QAEI,SAAA,SAASqH,GACZA,OAAAA,EAAMsO,MAAMyC,WAEpB,CACOhY,KAAAA,EAAgBJ,UAChB,KAAA,MAEI,SAAA,SAASqH,GACZ,OAAA,YAOT,KAAA,aA1CK,QAAA,QAAA;;AChBf,aAJA,QAAA,sBACA,IAAA,EAAA,EAAA,QAAA,SACA,EAAA,EAAA,QAAA,0CAEA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,IAAA,GAAA,mBAAA,QAAA,OAAA,KAAA,IAAA,EAAA,IAAA,QAAA,OAAA,EAAA,WAAA,OAAA,GAAA,EAAA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,IAAA,GAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,CAAA,IAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,KAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAK,UAAU,EAAf,QAAA,CAA0B,SAAS,eAAe,SAAW,SAAS,KAAM","file":"countdown.0a66d7ef.js","sourceRoot":"..\\src\\browser\\graphics","sourcesContent":["/* Riot v4.8.7, @license MIT */\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol.for('pure'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeNode);\n}\n/**\n * Remove a node from the DOM\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\n\nfunction removeNode(node) {\n  const {\n    parentNode\n  } = node;\n  if (node.remove) node.remove();\n  /* istanbul ignore else */\n  else if (parentNode) parentNode.removeChild(node);\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    children: Array.from(fragment.childNodes)\n  };\n}\n\nconst {\n  indexOf: iOF\n} = [];\n\nconst append = (get, parent, children, start, end, before) => {\n  const isSelect = 'selectedIndex' in parent;\n  let noSelection = isSelect;\n\n  while (start < end) {\n    const child = get(children[start], 1);\n    parent.insertBefore(child, before);\n\n    if (isSelect && noSelection && child.selected) {\n      noSelection = !noSelection;\n      let {\n        selectedIndex\n      } = parent;\n      parent.selectedIndex = selectedIndex < 0 ? start : iOF.call(parent.querySelectorAll('option'), child);\n    }\n\n    start++;\n  }\n};\n\nconst eqeq = (a, b) => a == b;\n\nconst identity = O => O;\n\nconst indexOf = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\n\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n\n  return futureEnd === 0;\n};\n\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\n\nconst remove = (get, children, start, end) => {\n  while (start < end) drop(get(children[start++], -1));\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const nodes = currentNodes.slice(currentStart, currentEnd);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const index = nodes.indexOf(futureNodes[i]);\n\n    if (-1 < index) {\n      const idxInOld = index + currentStart;\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = [];\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.push(futureNodes[futureStart]);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (-1 < live.indexOf(currentNodes[currentStart])) currentStart++;else remove(get, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n\nconst drop = node => (node.remove || dropChild).call(node);\n\nfunction dropChild() {\n  const {\n    parentNode\n  } = this;\n  /* istanbul ignore else */\n\n  if (parentNode) parentNode.removeChild(this);\n}\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, currentNodes, currentStart, i);\n        remove(get, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\n\n\nfunction checkType$1(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\n\nfunction isTemplate(el) {\n  return !isNil(el.content);\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\n\nfunction isFunction$1(value) {\n  return checkType$1(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\n\nfunction isBoolean(value) {\n  return checkType$1(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\n\nfunction isObject(value) {\n  return !isNil(value) && checkType$1(value, 'object');\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    domdiff(parent, nodes, futureNodes, {\n      before: placeholder,\n      node: patch(Array.from(childrenMap.values()), parentScope)\n    }); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const element = redundant.pop();\n\n      if (element) {\n        const {\n          template,\n          context\n        } = element; // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        template.unmount(context, parentScope, null);\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n    const mustMount = !oldItem;\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : {};\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      const children = meta.children || componentTemplate.children;\n      futureNodes.push(...children);\n    } else {\n      futureNodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  parent.insertBefore(placeholder, node);\n  removeNode(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n/**\n * Binding responsible for the `if` directive\n */\n\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      this.placeholder.parentNode.insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n});\n\nfunction create$1(node, _ref3) {\n  let {\n    evaluate,\n    template\n  } = _ref3;\n  const parent = node.parentNode;\n  const placeholder = document.createTextNode('');\n  parent.insertBefore(placeholder, node);\n  removeNode(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, {}, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref4) => {\n    let [name, value] = _ref4;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing all the attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref5, value, oldValue) {\n  let {\n    name\n  } = _ref5;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    } else if (oldValue) {\n      // otherwise remove all the old attributes\n      removeAllAttributes(node, oldValue);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction$1(value))) {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\n\nfunction getMethod(value) {\n  return isNil(value) || value === false || value === '' || isObject(value) || isFunction$1(value) ? REMOVE_ATTRIBUTE : SET_ATTIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - old expression value\n * @returns {value} the callback just received\n */\n\nfunction eventExpression(node, _ref6, value, oldValue) {\n  let {\n    name\n  } = _ref6;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  if (oldValue) {\n    node.removeEventListener(normalizedEventName, oldValue);\n  }\n\n  if (value) {\n    node.addEventListener(normalizedEventName, value, false);\n  }\n}\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {HTMLTextNode} the text node to update\n */\n\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = Object.seal({\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, {}, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\n\n\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref7) {\n  let {\n    expressions\n  } = _ref7;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n}\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref8) => {\n      let {\n        id\n      } = _ref8;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, this.getTemplateScope(scope, parentScope));\n      this.template.children = moveSlotInnerContent(this.node);\n    }\n\n    removeNode(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      this.template.update(this.getTemplateScope(scope, parentScope));\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @param   {HTMLElement} children - array to fill with the child nodes detected\n * @returns {HTMLElement[]} list of the node moved\n */\n\nfunction moveSlotInnerContent(slot, children) {\n  if (children === void 0) {\n    children = [];\n  }\n\n  const child = slot.firstChild;\n\n  if (child) {\n    slot.parentNode.insertBefore(child, slot);\n    return [child, ...moveSlotInnerContent(slot)];\n  }\n\n  return children;\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref9) {\n  let {\n    name,\n    attributes\n  } = _ref9;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref10) => {\n    let {\n      bindings\n    } = _ref10;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n});\n\nfunction create$4(node, _ref11) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref11;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$5(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n} // in this case a simple innerHTML is enough\n\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.children).indexOf(el), 0) : null;\n    this.isTemplateTag = isTemplateTag; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n\n    if (this.dom) {\n      // create the new template dom fragment if it want already passed in via meta\n      this.fragment = fragment || this.dom.cloneNode(true);\n    } // store root node\n    // notice that for template tags the root note will be the parent tag\n\n\n    this.el = this.isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && this.fragment) injectDOM(el, this.fragment); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n      switch (true) {\n        // <template> tags should be treated a bit differently\n        // we need to clear their children only if it's explicitly required by the caller\n        // via mustRemoveRoot !== null\n        case this.children && mustRemoveRoot !== null:\n          clearChildren(this.children);\n          break;\n        // remove the root node only if the mustRemoveRoot === true\n\n        case mustRemoveRoot === true:\n          removeNode(this.el);\n          break;\n        // otherwise we clean the node children\n\n        case mustRemoveRoot !== null:\n          cleanNode(this.el);\n          break;\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref) => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\nconst ATTRIBUTE$1 = 0;\nconst VALUE$1 = 3;\n\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase$1(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions$1(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE$1:\n        return Object.assign({}, acc, {}, value);\n      // value attribute\n\n      case type === VALUE$1:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase$1(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {Object} components - object containing the nested components\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [el] = args;\n      bindDOMNodeToComponentObject(el, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref2) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref2;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref3) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref3;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref4) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref4;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref5) => {\n    let [key, value] = _ref5;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, {}, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref6) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref6;\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, props, {}, evaluateAttributeExpressions$1(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions$1(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, props, {}, newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase$1(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = [];\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), {}, callOrAssign(initialProps));\n}\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, evaluateInitialProps(element, initialProps), name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already install');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helpter method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el), c => c({\n      props: evaluateInitialProps(el, props),\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.8.7'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version };\n","/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}","import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ?\n    (ctx || document).querySelectorAll(selector) :\n    selector\n  )\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('riot'), require('bianco.query')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'riot', 'bianco.query'], factory) :\n  (global = global || self, factory(global.riotHotReload = {}, global.riot, global.$));\n}(this, function (exports, riot, $) { 'use strict';\n\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n\n  const { cssManager } = riot.__;\n  const { DOM_COMPONENT_INSTANCE_PROPERTY } = riot.__.globals;\n\n  function reload(componentAPI) {\n    const {name} = componentAPI;\n\n    if (!name) {\n      console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n      return []\n    }\n\n    return $(`${name}, [is=${name}]`).map(el => {\n      const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n      // remove the tag template from the DOM\n      oldTag.unmount(true);\n      // delete the old css from the css manager\n      cssManager.remove(name);\n\n      // create the new tag\n      const newTag = riot.component(componentAPI)(el, oldTag.props);\n      newTag.update(oldTag.state);\n\n      return newTag\n    })\n  }\n\n  exports.default = reload;\n  exports.reload = reload;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","// Define logics about this component here.\r\nvar countdownRep = nodecg.Replicant('countdown');\r\nfunction Countdown() {\r\n    return {\r\n        state: {\r\n            formatted: '',\r\n            raw: 0,\r\n            progress: 0\r\n        },\r\n        onMounted: function () {\r\n            var _this = this;\r\n            countdownRep.on('change', function (newVal) {\r\n                _this.state.formatted = newVal.time.formatted;\r\n                _this.state.progress = (newVal.time.raw - (180 * 1000)) * -1;\r\n                _this.update();\r\n            });\r\n        }\r\n    };\r\n}\r\n\r\nexport default {\r\n  'css': `countdown,[is=\"countdown\"]{ padding: 0 0.5rem; color: white; font-size: 50vh; }`,\r\n  'exports': Countdown,\r\n\r\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\r\n    return template(\r\n      '<div expr10=\"expr10\" class=\"has-text-right is-italic\"> </div><progress expr11=\"expr11\" class=\"progress is-small\"></progress>',\r\n      [{\r\n        'redundantAttribute': 'expr10',\r\n        'selector': '[expr10]',\r\n\r\n        'expressions': [{\r\n          'type': expressionTypes.TEXT,\r\n          'childNodeIndex': 0,\r\n\r\n          'evaluate': function(scope) {\r\n            return ['\\r\\n        ', scope.state.formatted.split('.')[0], '\\r\\n    '].join('');\r\n          }\r\n        }]\r\n      }, {\r\n        'redundantAttribute': 'expr11',\r\n        'selector': '[expr11]',\r\n\r\n        'expressions': [{\r\n          'type': expressionTypes.ATTRIBUTE,\r\n          'name': 'value',\r\n\r\n          'evaluate': function(scope) {\r\n            return scope.state.progress;\r\n          }\r\n        }, {\r\n          'type': expressionTypes.ATTRIBUTE,\r\n          'name': 'max',\r\n\r\n          'evaluate': function(scope) {\r\n            return 180 * 1000;\r\n          }\r\n        }]\r\n      }]\r\n    );\r\n  },\r\n\r\n  'name': 'countdown'\r\n};","import \"@riotjs/hot-reload\";\r\nimport * as riot from \"riot\";\r\nimport Countdown from \"./components/countdown/countdown.riot\";\r\n\r\nriot.component(Countdown)(document.getElementById(\"root\") || document.body, {});\r\n"]}